from fastapi import APIRouter, UploadFile, File, HTTPException, Query, Depends
from backend.models.schemas import FlashcardRequest, FlashcardResponse, Flashcard
from backend.utils.save_helper import save_data, save_entry
from backend.auth import get_current_user
from backend.models.user import User
from fastapi_mail import FastMail, MessageSchema
from backend.services.mail_config import conf
from pypdf import PdfReader
from rake_nltk import Rake
from sumy.parsers.plaintext import PlaintextParser
from sumy.nlp.tokenizers import Tokenizer
from sumy.summarizers.luhn import LuhnSummarizer
import nltk
import os, re, json, glob, asyncio
from datetime import datetime
from typing import List

# -------------------------------------------
# ‚úÖ Router Setup
# -------------------------------------------
router = APIRouter(prefix="/flashcards", tags=["Flashcards"])

# -------------------------------------------
# ‚úÖ NLTK Dependencies (ensure cloud support)
# -------------------------------------------
for resource in ["stopwords", "punkt", "punkt_tab"]:
    try:
        nltk.data.find(f"tokenizers/{resource}" if "punkt" in resource else f"corpora/{resource}")
    except LookupError:
        print(f"üì¶ Downloading missing NLTK resource: {resource}")
        nltk.download(resource)

UPLOAD_DIR = "uploaded_pdfs"
SAVE_DIR = os.path.join("saved_files", "flashcards")
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(SAVE_DIR, exist_ok=True)

SAVE_FILE = os.path.join(SAVE_DIR, "saved_flashcards.json")
if not os.path.exists(SAVE_FILE):
    with open(SAVE_FILE, "w", encoding="utf-8") as f:
        json.dump([], f, indent=2)

# -------------------------------------------
# üì¨ Email Helper
# -------------------------------------------
async def send_flashcard_email(user_email: str, title: str, count: int):
    """Send async email after generating flashcards."""
    fm = FastMail(conf)
    subject = f"üß† AURA | Flashcards Generated: {title}"
    body = f"""
    <h3>üìö AURA Flashcards Ready</h3>
    <p><b>Title:</b> {title}</p>
    <p><b>Total Flashcards:</b> {count}</p>
    <hr>
    <p>Open your AURA app to review and practice these flashcards.</p>
    <p style="color:gray;font-size:12px;">Auto-generated by AURA‚Äôs Study Assistant.</p>
    """
    message = MessageSchema(subject=subject, recipients=[user_email], body=body, subtype="html")
    await fm.send_message(message)

# -------------------------------------------
# üì§ Upload PDF
# -------------------------------------------
@router.post("/upload-pdf/")
async def upload_pdf(file: UploadFile = File(...), current_user: User = Depends(get_current_user)):
    """Upload a PDF and link it to the user."""
    path = os.path.join(UPLOAD_DIR, file.filename)
    with open(path, "wb") as f:
        f.write(await file.read())
    return {"pdf_path": path, "filename": file.filename, "user": current_user.email}

# -------------------------------------------
# üß† Helpers
# -------------------------------------------
def _extract_text_from_pdf(path: str) -> str:
    reader = PdfReader(path)
    buf = [p.extract_text() or "" for p in reader.pages]
    return "\n".join(buf)

def _summarize_text(text: str, num_sentences: int = 10) -> str:
    clean_text = re.sub(r"\s+", " ", text.strip())
    try:
        parser = PlaintextParser.from_string(clean_text, Tokenizer("english"))
        summarizer = LuhnSummarizer()
        summary = summarizer(parser.document, num_sentences)
        summarized = " ".join(str(sentence) for sentence in summary)
        return summarized if len(summarized.split()) > 20 else clean_text
    except Exception as e:
        print(f"‚ö†Ô∏è Summarization failed: {e}")
        return clean_text

def _keyword_phrases(text: str, topn: int = 30) -> List[str]:
    r = Rake()
    r.extract_keywords_from_text(text)
    return r.get_ranked_phrases()[:topn]

def _make_cloze(sentence: str, term: str):
    pat = re.compile(re.escape(term), re.IGNORECASE)
    return pat.sub("____", sentence)

# -------------------------------------------
# ‚öôÔ∏è Generate Flashcards (Adaptive + Email)
# -------------------------------------------
@router.post("/generate", response_model=FlashcardResponse)
async def generate_flashcards(req: FlashcardRequest, current_user: User = Depends(get_current_user)):
    """Generate adaptive flashcards and email results."""
    if req.pdf_path:
        text = _extract_text_from_pdf(req.pdf_path)
        source = os.path.basename(req.pdf_path)
    else:
        text = req.text or ""
        source = "Manual Text Input"

    if not text.strip():
        raise HTTPException(status_code=400, detail="No valid text found")

    # üß† Adaptive flashcard count
    word_count = len(text.split())
    if word_count < 500:
        num_cards = 5
    elif word_count < 1500:
        num_cards = 10
    elif word_count < 3000:
        num_cards = 15
    else:
        num_cards = 25

    summarized_text = _summarize_text(text, num_sentences=10)
    phrases = _keyword_phrases(summarized_text, topn=num_cards * 2)
    sentences = re.split(r"[\.!?]\s+", summarized_text)
    cards: List[Flashcard] = []

    for term in phrases:
        for s in sentences:
            if re.search(re.escape(term), s, re.IGNORECASE) and len(s) > 30:
                q = _make_cloze(s, term)
                a = term
                cards.append(Flashcard(q=q, a=a, tags=["auto"]))
                break
        if len(cards) >= num_cards:
            break

    title = f"Flashcards from {source}"
    entry = {
        "email": current_user.email,
        "title": title,
        "content": f"{len(cards)} flashcards generated.",
        "metadata": {"source": source, "num_cards": len(cards), "cards": [card.dict() for card in cards]},
        "timestamp": datetime.utcnow().isoformat(),
    }

    # Save to JSON
    with open(SAVE_FILE, "r+", encoding="utf-8") as f:
        data = json.load(f)
        data.append(entry)
        f.seek(0)
        json.dump(data, f, indent=2)

    # Save backup file
    backup_file = os.path.join(SAVE_DIR, f"{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{current_user.email.replace('@','_')}.txt")
    with open(backup_file, "w", encoding="utf-8") as f:
        f.write(f"User: {current_user.email}\n")
        f.write(f"Timestamp: {entry['timestamp']}\n\n")
        for i, card in enumerate(cards, 1):
            f.write(f"Q{i}: {card.q}\nA{i}: {card.a}\n\n")

    # Send email asynchronously
    asyncio.create_task(send_flashcard_email(current_user.email, title, len(cards)))

    return FlashcardResponse(cards=cards)

# -------------------------------------------
# üìö Get User's Saved Flashcards
# -------------------------------------------
@router.get("/saved")
async def get_saved_flashcards(current_user: User = Depends(get_current_user)):
    """Return flashcards saved for this user only."""
    try:
        with open(SAVE_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        user_cards = [e for e in data if e.get("email") == current_user.email]
        user_cards.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
        return {"entries": user_cards}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to load flashcards: {e}")

# ‚úÖ Alias for frontend Saved Files compatibility
@router.get("/notes/list/flashcards")
async def get_flashcards_alias(current_user: User = Depends(get_current_user)):
    return await get_saved_flashcards(current_user)
