from fastapi import APIRouter, UploadFile, File, HTTPException, Depends
from backend.models.schemas import FlashcardRequest, FlashcardResponse, Flashcard
from backend.routers.auth import get_current_user
from backend.models.user import User
from fastapi_mail import FastMail, MessageSchema
from backend.services.mail_config import conf
from pypdf import PdfReader
from rake_nltk import Rake
from sumy.parsers.plaintext import PlaintextParser
from sumy.nlp.tokenizers import Tokenizer
from sumy.summarizers.luhn import LuhnSummarizer
from groq import Groq
import nltk
import os, re, json, asyncio
from datetime import datetime
from typing import List

# -------------------------------------------
# ‚úÖ Router Setup
# -------------------------------------------
router = APIRouter(prefix="/flashcards", tags=["Flashcards"])

# -------------------------------------------
# ‚úÖ NLTK Dependencies
# -------------------------------------------
for resource in ["stopwords", "punkt", "punkt_tab"]:
    try:
        nltk.data.find(f"tokenizers/{resource}" if "punkt" in resource else f"corpora/{resource}")
    except LookupError:
        print(f"üì¶ Downloading missing NLTK resource: {resource}")
        nltk.download(resource)

# -------------------------------------------
# ‚úÖ Groq AI Setup (fallback model)
# -------------------------------------------
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
client = Groq(api_key=GROQ_API_KEY) if GROQ_API_KEY else None

# -------------------------------------------
# üìÅ File Directories
# -------------------------------------------
UPLOAD_DIR = "uploaded_pdfs"
SAVE_DIR = os.path.join("saved_files", "flashcards")
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(SAVE_DIR, exist_ok=True)

SAVE_FILE = os.path.join(SAVE_DIR, "saved_flashcards.json")
if not os.path.exists(SAVE_FILE):
    with open(SAVE_FILE, "w", encoding="utf-8") as f:
        json.dump([], f, indent=2)

# -------------------------------------------
# üì¨ Email Helper
# -------------------------------------------
async def send_flashcard_email(user_email: str, title: str, count: int):
    """Send async email after generating flashcards."""
    try:
        fm = FastMail(conf)
        subject = f"üß† AURA | Flashcards Generated: {title}"
        body = f"""
        <h3>üìö AURA Flashcards Ready</h3>
        <p><b>Title:</b> {title}</p>
        <p><b>Total Flashcards:</b> {count}</p>
        <hr>
        <p>Open your AURA app to review and practice these flashcards.</p>
        <p style="color:gray;font-size:12px;">Auto-generated by AURA‚Äôs Study Assistant.</p>
        """
        message = MessageSchema(subject=subject, recipients=[user_email], body=body, subtype="html")
        await fm.send_message(message)
    except Exception as e:
        print(f"‚ö†Ô∏è Email skipped: {e}")

# -------------------------------------------
# üì§ Upload PDF
# -------------------------------------------
@router.post("/upload-pdf/")
async def upload_pdf(file: UploadFile = File(...), current_user: User = Depends(get_current_user)):
    """Upload a PDF and link it to the user."""
    path = os.path.join(UPLOAD_DIR, file.filename)
    with open(path, "wb") as f:
        f.write(await file.read())
    return {"pdf_path": path, "filename": file.filename, "user": current_user.email}

# -------------------------------------------
# üß† Helper Functions
# -------------------------------------------
def _extract_text_from_pdf(path: str) -> str:
    reader = PdfReader(path)
    buf = [p.extract_text() or "" for p in reader.pages]
    return "\n".join(buf)

def _summarize_text(text: str, num_sentences: int = 10) -> str:
    clean_text = re.sub(r"\s+", " ", text.strip())
    try:
        parser = PlaintextParser.from_string(clean_text, Tokenizer("english"))
        summarizer = LuhnSummarizer()
        summary = summarizer(parser.document, num_sentences)
        summarized = " ".join(str(sentence) for sentence in summary)
        return summarized if len(summarized.split()) > 20 else clean_text
    except Exception as e:
        print(f"‚ö†Ô∏è Summarization failed: {e}")
        return clean_text

def _keyword_phrases(text: str, topn: int = 30) -> List[str]:
    r = Rake()
    r.extract_keywords_from_text(text)
    return r.get_ranked_phrases()[:topn]

def _make_cloze(sentence: str, term: str):
    pat = re.compile(re.escape(term), re.IGNORECASE)
    return pat.sub("____", sentence)

# -------------------------------------------
# ‚öôÔ∏è Generate Flashcards (NLP + Groq Fallback)
# -------------------------------------------
@router.post("/generate", response_model=FlashcardResponse)
async def generate_flashcards(req: FlashcardRequest, current_user: User = Depends(get_current_user)):
    """Generate adaptive flashcards using NLP or Groq AI fallback."""
    try:
        # Step 1: Get Text
        if req.pdf_path:
            text = _extract_text_from_pdf(req.pdf_path)
            source = os.path.basename(req.pdf_path)
        else:
            text = req.text or ""
            source = "Manual Text Input"

        if not text.strip():
            raise HTTPException(status_code=400, detail="No valid text found")

        word_count = len(text.split())
        print(f"üß† Flashcard generation started for {current_user.email}, {word_count} words")

        # Step 2: Dynamic Card Count
        if word_count < 300:
            num_cards = 5
        elif word_count < 1000:
            num_cards = 10
        elif word_count < 2500:
            num_cards = 15
        else:
            num_cards = 25

        # Step 3: Summarization + Keywords
        summarized_text = _summarize_text(text, num_sentences=8)
        if len(summarized_text.split()) < 40:
            summarized_text = text  # fallback if too short

        phrases = _keyword_phrases(summarized_text, topn=num_cards * 3)
        sentences = re.split(r"[\.!?]\s+", summarized_text)
        cards: List[Flashcard] = []

        # Step 4: NLP-based Cloze Cards
        for term in phrases:
            for s in sentences:
                if re.search(re.escape(term), s, re.IGNORECASE) and len(s) > 25:
                    q = _make_cloze(s, term)
                    a = term
                    cards.append(Flashcard(q=q, a=a, tags=["NLP"]))
                    break
            if len(cards) >= num_cards:
                break

        # Step 5: Fallback ‚Äì Groq AI Generation
        if len(cards) == 0 and client:
            print("‚öôÔ∏è Using Groq AI to generate flashcards...")
            prompt = f"""
            Generate {num_cards} educational flashcards (question-answer pairs)
            based on the following text. Keep questions short and factual.

            TEXT:
            {text[:4000]}
            """

            try:
                response = client.chat.completions.create(
                    model="llama-3.3-70b-versatile",
                    messages=[
                        {"role": "system", "content": "You are an educational flashcard generator."},
                        {"role": "user", "content": prompt},
                    ],
                    temperature=0.6,
                    max_tokens=800,
                )

                ai_output = response.choices[0].message.content.strip()
                print(f"ü§ñ Groq response preview: {ai_output[:200]}...")

                lines = [line.strip() for line in ai_output.split("\n") if line.strip()]
                for line in lines:
                    if ":" in line:
                        q, a = line.split(":", 1)
                        cards.append(Flashcard(q=q.strip(), a=a.strip(), tags=["AI"]))
                    elif "?" in line:
                        parts = line.split("?")
                        q = parts[0] + "?"
                        a = parts[1].strip() if len(parts) > 1 else "Not specified"
                        cards.append(Flashcard(q=q, a=a, tags=["AI"]))
                    if len(cards) >= num_cards:
                        break

                print(f"‚úÖ Groq AI generated {len(cards)} flashcards")

            except Exception as e:
                print(f"‚ö†Ô∏è Groq fallback failed: {e}")

        # Step 6: Final fallback
        if len(cards) == 0:
            cards.append(
                Flashcard(
                    q="What is the main idea of this text?",
                    a=text[:150] + "...",
                    tags=["fallback"],
                )
            )
            print("‚ö†Ô∏è Fallback: 1 generic flashcard created")

        # Step 7: Save Flashcards
        title = f"Flashcards from {source}"
        entry = {
            "email": current_user.email,
            "title": title,
            "content": f"{len(cards)} flashcards generated.",
            "metadata": {"source": source, "num_cards": len(cards), "cards": [card.dict() for card in cards]},
            "timestamp": datetime.utcnow().isoformat(),
        }

        with open(SAVE_FILE, "r+", encoding="utf-8") as f:
            data = json.load(f)
            data.append(entry)
            f.seek(0)
            json.dump(data, f, indent=2)

        asyncio.create_task(send_flashcard_email(current_user.email, title, len(cards)))
        print(f"üíæ Saved {len(cards)} flashcards for {current_user.email}")

        return FlashcardResponse(cards=cards)

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Flashcard generation failed: {e}")

# -------------------------------------------
# üìö Get User's Saved Flashcards
# -------------------------------------------
@router.get("/saved")
async def get_saved_flashcards(current_user: User = Depends(get_current_user)):
    """Return flashcards saved for this user only."""
    try:
        with open(SAVE_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        user_cards = [e for e in data if e.get("email") == current_user.email]
        user_cards.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
        return {"entries": user_cards}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to load flashcards: {e}")

# ‚úÖ Alias for Saved Files compatibility
@router.get("/notes/list/flashcards")
async def get_flashcards_alias(current_user: User = Depends(get_current_user)):
    return await get_saved_flashcards(current_user)
